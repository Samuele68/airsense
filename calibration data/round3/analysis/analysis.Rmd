---
title: "Analysis of long term data"
output: html_notebook
---

Analysis of the data sets using linear regression.
See [this very nice post for an introduction with R](https://www.dataquest.io/blog/statistical-learning-for-predictive-modeling-r/).

Let's first open the round 1 data.

Collection of data was started on 18 / 5 / 2017
0 ms at sensor
16:49 at mobile phone
15:53 at monitor time (+/- 2 minutes !)

Was stopped on 24 / 5 / 2017
516905067 ms at sensor
16:32 at mobile phone

```{r}
round1_raw <- read.csv(file="../../round1/data/AIRSENSE.CSV", header=TRUE, sep=" ", stringsAsFactors = FALSE)

start_TS <- as.POSIXct('2017-05-18 15:53:00')

round1_raw$timestamp <- start_TS + floor(round1_raw$timestamp / 1000)

# -1 are actually failures
round1_raw$humidity <- ifelse(round1_raw$humidity == -1, NA, round1_raw$humidity)
round1_raw$temperature <- ifelse(round1_raw$temperature == -1, NA, round1_raw$temperature)
names(round1_raw)[names(round1_raw) == "rawNO2_Mics"] <- "custom_MICS"

round1_ref <- read.csv(file="../../round1/data/reference.csv", header=TRUE, sep=",", stringsAsFactors = FALSE)
names(round1_ref)[names(round1_ref) == "TimeStamp"] <- "timestamp"
names(round1_ref)[names(round1_ref) == "NO2CNC1.AVG.PPB."] <- "NO2"
names(round1_ref)[names(round1_ref) == "NOXCNC1.AVG.PPB."] <- "NOX"
names(round1_ref)[names(round1_ref) == "NOCNC1.AVG.PPB."] <- "NO"

round1_ref$timestamp <- as.POSIXct(round1_ref$timestamp, format='%m/%d/%Y %H:%M:%S')

rm(start_TS)
```

Now we need to make the timestamps match

```{r}
first_useful_ts <- max(round1_raw$timestamp[1], round1_ref$timestamp[1])
last_useful_ts <- min(round1_raw$timestamp[nrow(round1_raw)], round1_ref$timestamp[nrow(round1_ref)])

# cut the data between these two

round1_raw <- round1_raw[which(round1_raw$timestamp <= last_useful_ts & round1_raw$timestamp >= first_useful_ts ), ]

round1_ref <- round1_ref[which(round1_ref$timestamp <= last_useful_ts & round1_ref$timestamp >= first_useful_ts ), ]

# now the let's match the two data sets, we'll interpolate the raw data to match the reference

interpolate <- function (raw, ref, colname) {
  ip <- approx(raw$timestamp,raw[[colname]], xout = ref$timestamp, rule = 2, method = "linear", ties = mean)
  temp <- data.frame(timestamp = ip$x, col = ip$y)
  names(temp)[names(temp) == 'col'] <- colname
  return(temp)
}

temp_raw <- data.frame()

for (name in names(round1_raw)) {
  if (name != 'timestamp') {
    if (nrow(temp_raw) == 0) {
      temp_raw = interpolate(round1_raw, round1_ref, name)
    } else {
      t = interpolate(round1_raw, round1_ref, name)
      temp_raw[[name]] = t[[name]]
    }
  }
}
round1_raw<- temp_raw

rm(t, temp_raw, name)
```

Instead of using all the samples, we can use 30 minutes averages:

```{r}
subsample <- function(data, interval) {
  temp = split(data, cut(strptime(data$timestamp, format="%F %R"), interval))
  
  subsampled = data.frame(timestamp = names(temp))
  for (name in names(data)) {
    if (name != 'timestamp') {
      avgs = sapply(temp, function(x)mean(x[[name]]))
      subsampled[[name]] = avgs
    }
  }
  subsampled
}

round1_raw_ss <- subsample(round1_raw, '30 mins')
round1_raw_ss$timestamp <- as.POSIXct(round1_raw_ss$timestamp)
round1_ref_ss <- subsample(round1_ref, '30 mins')
round1_ref_ss$timestamp <- as.POSIXct(round1_ref_ss$timestamp)
```

Let's put all inside one dataframe:

```{r}
round1_ss <- round1_raw_ss
round1_ss$refNO2 = round1_ref_ss$NO2

#let's add the squared of each input
round1_ss$temperature_sq = round1_ss$temperature ^ 2
round1_ss$humidity_sq = round1_ss$humidity ^ 2
round1_ss$custom_MICS_sq = round1_ss$custom_MICS ^ 2

# we can delete the other data
rm(round1_raw_ss, round1_ref_ss)
```

Let's do the linear regression using mics, temperature and humidity and their 2nd power too.
I hypothesis that custom_MICS can interact with temperature and humidity but not their powers.

```{r}
round1_model_thm <- lm(refNO2 ~
                          custom_MICS + custom_MICS_sq +
                          temperature_sq + humidity_sq +
                          custom_MICS * temperature +
                          custom_MICS * humidity
                        , data=round1_ss)
summary(round1_model_thm)

errs_r1_m_thm_r1 <- data.frame(timestamp = round1_ss$timestamp, reference = round1_ss$refNO2, fitted = fitted(round1_model_thm))

print(paste('mean error', mean(errs_r1_m_thm_r1$reference - errs_r1_m_thm_r1$fitted), 'ppb'))
print(paste('mean absolute error', mean(abs(errs_r1_m_thm_r1$reference - errs_r1_m_thm_r1$fitted)), 'ppb'))
```

From the coefficients, it looks like the temperature has a big effect on the measurement.
The product of MICS and temp or hum doesn't have a big effect, but let's keep it there for the moment.

Which will look like this:

```{r}
xrange <- range(errs_r1_m_thm_r1$timestamp)
yrange <- range(errs_r1_m_thm_r1$timestamp)

plot(errs_r1_m_thm_r1$timestamp, errs_r1_m_thm_r1$reference, type='l', xlab='time', ylab='ppb', col = 'red')
axis.POSIXct(1, at=seq(xrange[1], xrange[2], by="day"), format="%b %d")
lines(errs_r1_m_thm_r1$timestamp, errs_r1_m_thm_r1$fitted, type='l', lty = 2, col = 'blue')
legend("topright", legend = c("reference", "fitted"),
       text.width = strwidth("reference"),
       col=c('red', 'blue'),
       lty = 1:2, xjust = 1, yjust = 1)

rm(xrange, yrange)
```

## Round 2

Now let's basically repeat the same for round 2:

- Started: 10/01/2018
11:22:39 at mobile phone
11:23:21 at reference
0 at sensor

Let's load and parse the data:

```{r}
round2_raw <- read.csv(file="../../round2/data/AIRSENSE.CSV", header=TRUE, sep=",", stringsAsFactors = FALSE)

start_TS <- as.POSIXct('2018-01-10 11:23:21')

round2_raw$timestamp <- start_TS + floor(round2_raw$timestamp / 1000)

# -1 are actually failures
round2_raw$humidity <- ifelse(round2_raw$humidity == -1, NA, round2_raw$humidity)
round2_raw$temperature <- ifelse(round2_raw$temperature == -1, NA, round2_raw$temperature)
# remove data that was not gathered
round2_raw <- round2_raw[ , -which(names(round2_raw) %in% c('ratio_NH3','ratio_CO','ratio_NO2', 'nh3', 'co', 'no2', 'c3h8', 'c4h10', 'ch4', 'h2', 'c2h5oh'))]

round2_ref <- read.csv(file="../../round2/data/reference.csv", header=TRUE, sep=",", stringsAsFactors = FALSE)
round2_ref$timestamp <- as.POSIXct(paste(round2_ref$Date, round2_ref$Time))
round2_ref <- round2_ref[ , -which(names(round2_ref) %in% c('Date','Time'))]
names(round2_ref)[names(round2_ref) == "NO2CNC1"] <- "NO2"
names(round2_ref)[names(round2_ref) == "NOXCNC1"] <- "NOX"
names(round2_ref)[names(round2_ref) == "NOCNC1"] <- "NO"

rm(start_TS)
```

Now we need to make the timestamps match

```{r}
first_useful_ts <- max(round2_raw$timestamp[1], round2_ref$timestamp[1])
last_useful_ts <- min(round2_raw$timestamp[nrow(round2_raw)], round2_ref$timestamp[nrow(round2_ref)])

round2_raw <- round2_raw[which(round2_raw$timestamp <= last_useful_ts & round2_raw$timestamp >= first_useful_ts ), ]
round2_ref <- round2_ref[which(round2_ref$timestamp <= last_useful_ts & round2_ref$timestamp >= first_useful_ts ), ]

temp_raw <- data.frame()

for (name in names(round2_raw)) {
  if (name != 'timestamp') {
    if (nrow(temp_raw) == 0) {
      temp_raw = interpolate(round2_raw, round2_ref, name)
    } else {
      t = interpolate(round2_raw, round2_ref, name)
      temp_raw[[name]] = t[[name]]
    }
  }
}
round2_raw<- temp_raw

rm(t, temp_raw, name)
```

Use 30 minutes averages:

```{r}
subsample <- function(data, interval) {
  temp = split(data, cut(strptime(data$timestamp, format="%F %R"), interval))
  
  subsampled = data.frame(timestamp = names(temp))
  for (name in names(data)) {
    if (name != 'timestamp') {
      avgs = sapply(temp, function(x)mean(x[[name]]))
      subsampled[[name]] = avgs
    }
  }
  subsampled
}

round2_raw_ss <- subsample(round2_raw, '30 mins')
round2_raw_ss$timestamp <- as.POSIXct(round2_raw_ss$timestamp)
round2_ref_ss <- subsample(round2_ref, '30 mins')
round2_ref_ss$timestamp <- as.POSIXct(round2_ref_ss$timestamp)
```

Here there are some "holes" in the data that will cause trouble later, we need to get rid of them:

```{r}
round2_raw_ss = round2_raw_ss[which(!is.na(round2_raw_ss$custom_MICS)), ]
round2_ref_ss = round2_ref_ss[which(!is.na(round2_raw_ss$custom_MICS)), ]
round2_raw_ss = round2_raw_ss[which(!is.na(round2_ref_ss$NO2)), ]
round2_ref_ss = round2_ref_ss[which(!is.na(round2_ref_ss$NO2)), ]
```

Let's put everything into one data frame:

```{r}
round2_ss <- round2_raw_ss
round2_ss$refNO2 = round2_ref_ss$NO2

#let's add the squared of each input
round2_ss$temperature_sq = round2_ss$temperature ^ 2
round2_ss$humidity_sq = round2_ss$humidity ^ 2
round2_ss$custom_MICS_sq = round2_ss$custom_MICS ^ 2
round2_ss$pressure_sq = round2_ss$pressure ^ 2
round2_ss$alphadiff_sq = round2_ss$alphadiff ^ 2

# we can delete the other data
rm(round2_raw_ss, round2_ref_ss)
```


What happens if we use the model from round 1 on the data from round 2?

```{r}
errs_r1_m_thm_r2 <- data.frame(timestamp = round2_ss$timestamp, reference = round2_ss$refNO2, fitted = predict(round1_model_thm, round2_ss))

print(paste('mean error', mean(errs_r1_m_thm_r2$reference - errs_r1_m_thm_r2$fitted), 'ppb'))
print(paste('mean absolute error', mean(abs(errs_r1_m_thm_r2$reference - errs_r1_m_thm_r2$fitted)), 'ppb'))

xrange <- range(errs_r1_m_thm_r2$timestamp)

plot(errs_r1_m_thm_r2$timestamp, errs_r1_m_thm_r2$reference, type='l', xlab='time', ylab='ppb', col = 'red')
axis.POSIXct(1, at=seq(xrange[1], xrange[2], by="day"), format="%b %d")
lines(errs_r1_m_thm_r2$timestamp, errs_r1_m_thm_r2$fitted, type='l', lty = 2, col = 'blue')
legend("topright", legend = c("reference", "fitted_r1"),
       text.width = strwidth("reference"),
       col=c('red', 'blue'),
       lty = 1:2, xjust = 1, yjust = 1)

rm(xrange)

```

Performances are quite crap.


Now let's create a model for round 2, we will create one with only temperature, humidity and MICS as done before:

```{r}
round2_model_thm <- lm(refNO2 ~
                          custom_MICS + custom_MICS_sq +
                          temperature_sq + humidity_sq +
                          custom_MICS * temperature +
                          custom_MICS * humidity
                        , data=round2_ss)
summary(round2_model_thm)

errs_r2_m_thm_r2 <- data.frame(timestamp = round2_ss$timestamp, reference = round2_ss$refNO2, fitted = fitted(round2_model_thm))

print(paste('mean error', mean(errs_r2_m_thm_r2$reference - errs_r2_m_thm_r2$fitted), 'ppb'))
print(paste('mean absolute error', mean(abs(errs_r2_m_thm_r2$reference - errs_r2_m_thm_r2$fitted)), 'ppb'))

xrange <- range(errs_r2_m_thm_r2$timestamp)

plot(errs_r2_m_thm_r2$timestamp, errs_r2_m_thm_r2$reference, type='l', xlab='time', ylab='ppb', col = 'red')
axis.POSIXct(1, at=seq(xrange[1], xrange[2], by="day"), format="%b %d")
lines(errs_r2_m_thm_r2$timestamp, errs_r2_m_thm_r2$fitted, type='l', lty = 2, col = 'blue')
legend("topright", legend = c("reference", "fitted"),
       text.width = strwidth("reference"),
       col=c('red', 'blue'),
       lty = 1:2, xjust = 1, yjust = 1)

rm(xrange)
```

It works, but it's not great. Now let's also add pressure and the alphasense sensor diff.
I hypotehise that the alpha sensor has interaction with temp, hum and pressure like the MICS:

```{r}
round2_model_thmpa <- lm(refNO2 ~
                            temperature_sq + humidity_sq + pressure_sq +
                            
                            custom_MICS + custom_MICS_sq +
                            custom_MICS * temperature +
                            custom_MICS * humidity +
                            custom_MICS * pressure +
                            
                            alphadiff + alphadiff_sq +
                            alphadiff * temperature +
                            alphadiff * humidity +
                            alphadiff * pressure
                          , data=round2_ss)
summary(round2_model_thmpa)

errs_r2_m_thmpa_r2 <- data.frame(timestamp = round2_ss$timestamp, reference = round2_ss$refNO2, fitted = fitted(round2_model_thmpa))

print(paste('mean error', mean(errs_r2_m_thmpa_r2$reference - errs_r2_m_thmpa_r2$fitted), 'ppb'))
print(paste('mean absolute error', mean(abs(errs_r2_m_thmpa_r2$reference - errs_r2_m_thmpa_r2$fitted)), 'ppb'))

xrange <- range(errs_r2_m_thmpa_r2$timestamp)

plot(errs_r2_m_thmpa_r2$timestamp, errs_r2_m_thmpa_r2$reference, type='l', xlab='time', ylab='ppb', col = 'red')
axis.POSIXct(1, at=seq(xrange[1], xrange[2], by="day"), format="%b %d")
lines(errs_r2_m_thmpa_r2$timestamp, errs_r2_m_thmpa_r2$fitted, type='l', lty = 2, col = 'blue')
legend("topright", legend = c("reference", "fitted"),
       text.width = strwidth("reference"),
       col=c('red', 'blue'),
       lty = 1:2, xjust = 1, yjust = 1)

rm(xrange)
```

Now, this looks much, much better.

Let's notice one thing: pressure has quite low effect on the sensors, maybe it's worth actually removing it completely:

```{r}
round2_model_thma <- lm(refNO2 ~
                            temperature_sq + humidity_sq +
                            
                            custom_MICS + custom_MICS_sq +
                            custom_MICS * temperature +
                            custom_MICS * humidity +

                            alphadiff + alphadiff_sq +
                            alphadiff * temperature +
                            alphadiff * humidity
                          , data=round2_ss)
summary(round2_model_thma)

errs_r2_m_thma_r2 <- data.frame(timestamp = round2_ss$timestamp, reference = round2_ss$refNO2, fitted = fitted(round2_model_thma))

print(paste('mean error', mean(errs_r2_m_thma_r2$reference - errs_r2_m_thma_r2$fitted), 'ppb'))
print(paste('mean absolute error', mean(abs(errs_r2_m_thma_r2$reference - errs_r2_m_thma_r2$fitted)), 'ppb'))

xrange <- range(errs_r2_m_thma_r2$timestamp)

plot(errs_r2_m_thma_r2$timestamp, errs_r2_m_thma_r2$reference, type='l', xlab='time', ylab='ppb', col = 'red')
axis.POSIXct(1, at=seq(xrange[1], xrange[2], by="day"), format="%b %d")
lines(errs_r2_m_thma_r2$timestamp, errs_r2_m_thma_r2$fitted, type='l', lty = 2, col = 'blue')
legend("topright", legend = c("reference", "fitted"),
       text.width = strwidth("reference"),
       col=c('red', 'blue'),
       lty = 1:2, xjust = 1, yjust = 1)

rm(xrange)
```
The accuracy is worse, but let's keep this model for comparison.


## Round 3

Here the data sets are a bit different, let's load them:

Started on 2/01/2019 at 13:45:48
Time at the monitoring station: 13:47:29

```{r}
round3_raw <- read.csv(file="../data/airsense.csv", header=TRUE, sep=",", stringsAsFactors = FALSE)

round3_raw$timestamp <- as.POSIXct(sub('\\..*', '', round3_raw$timestamp), format='%Y-%m-%dT%H:%M:%S')

# to match time on the station, we need to move all timestamps by a time difference:

td <- difftime(as.POSIXct('2/01/2019 13:45:48', format='%d/%m/%Y %H:%M:%S'), as.POSIXct('2/01/2019 13:47:29', format='%d/%m/%Y %H:%M:%S'), units = c('secs'))

round3_raw$timestamp <- round3_raw$timestamp - td

round2_raw$humidity <- ifelse(round2_raw$humidity == -1, NA, round2_raw$humidity)
round2_raw$temperature <- ifelse(round2_raw$temperature == -1, NA, round2_raw$temperature)
```

Reference data is split among different files:

```{r}
#round3_ref <- read.csv(file="../data/reference_2019-01-04_2019-01-17.csv", header=TRUE, sep=";", stringsAsFactors = FALSE)
#round3_ref$timestamp <- as.POSIXct(round3_ref$datetime, format='%d-%m-%y %H:%M')
#round3_ref$NOX <- rep(NA, nrow(round3_ref))
#round3_ref$NO <- rep(NA, nrow(round3_ref))
#round3_ref <- round3_ref[ , -which(names(round3_ref) %in% c('datetime'))]

round3_ref <- data.frame()

readLogCSV <- function(filename) {
  temp <- read.csv(file=filename, header=TRUE, sep=",", stringsAsFactors = FALSE)
  names(temp)[names(temp) == "NO2CNC1"] <- "NO2"
  names(temp)[names(temp) == "NOXCNC1"] <- "NOX"
  names(temp)[names(temp) == "NOCNC1"] <- "NO"

  temp$timestamp <- as.POSIXct(paste(temp$Date, temp$Time), format='%Y/%m/%d %H:%M')
  temp <- temp[ , -which(names(temp) %in% c('Date', 'Time'))]  
  temp
}

round3_ref <- readLogCSV("../data/Log-20190118-102419.log.csv")
round3_ref <- rbind(round3_ref, readLogCSV("../data/Log-20190122-093909.log.csv"))
round3_ref <- rbind(round3_ref, readLogCSV("../data/Log-20190129-114056.log.csv"))
round3_ref <- rbind(round3_ref, readLogCSV("../data/Log-20190201-110630.log.csv"))
round3_ref <- rbind(round3_ref, readLogCSV("../data/Log-20190204-140411.log.csv"))
round3_ref <- rbind(round3_ref, readLogCSV("../data/Log-20190208-150109.log.csv"))
round3_ref <- rbind(round3_ref, readLogCSV("../data/Log-20190211-102551.log.csv"))
round3_ref <- rbind(round3_ref, readLogCSV("../data/Log-20190214-104139.log.csv"))
round3_ref <- rbind(round3_ref, readLogCSV("../data/Log-20190219-084616.log.csv"))
round3_ref <- rbind(round3_ref, readLogCSV("../data/Log-20190301-115140.log.csv"))
round3_ref <- rbind(round3_ref, readLogCSV("../data/Log-20190311-114102.log.csv"))

```

Cleanup and put everything together:

```{r}
first_useful_ts <- max(round3_raw$timestamp[1], round3_ref$timestamp[1])
last_useful_ts <- min(round3_raw$timestamp[nrow(round3_raw)], round3_ref$timestamp[nrow(round3_ref)])

round3_raw <- round3_raw[which(round3_raw$timestamp <= last_useful_ts & round3_raw$timestamp >= first_useful_ts ), ]
round3_ref <- round3_ref[which(round3_ref$timestamp <= last_useful_ts & round3_ref$timestamp >= first_useful_ts ), ]

# remove holes of more than 5 minutes:
for (i in 2:nrow(round3_ref)) {
  if (difftime(round3_ref[i, 'timestamp'], round3_ref[i-1, 'timestamp'], units=c('mins')) > 5 ) {
    print(paste('hole found in ref data: start', round3_ref[i-1, 'timestamp'], 'end', round3_ref[i, 'timestamp']))
    round3_raw <- round3_raw[which(! (round3_raw$timestamp > round3_ref[i-1, 'timestamp'] & round3_raw$timestamp < round3_ref[i, 'timestamp'])), ]
  }
}

for (i in 2:nrow(round3_raw)) {
  if (difftime(round3_raw[i, 'timestamp'], round3_raw[i-1, 'timestamp'], units=c('mins')) > 5 ) {
    print(paste('hole found in raw data: start', round3_raw[i-1, 'timestamp'], 'end', round3_raw[i, 'timestamp']))
    round3_ref <- round3_ref[which(! (round3_ref$timestamp > round3_raw[i-1, 'timestamp'] & round3_ref$timestamp < round3_raw[i, 'timestamp'])), ]
  }
}

# all data between 00:45 and 1:05 is noise and has to be removed from analysis
round3_raw <- round3_raw[ - which((as.numeric(format(round3_raw$timestamp, "%H")) == 0 &
                       as.numeric(format(round3_raw$timestamp, "%M")) >=45) |
                      (as.numeric(format(round3_raw$timestamp, "%H")) == 1 &
                         as.numeric(format(round3_raw$timestamp, "%M")) <=5)), ]

round3_ref <- round3_ref[ - which((as.numeric(format(round3_ref$timestamp, "%H")) == 0 &
                       as.numeric(format(round3_ref$timestamp, "%M")) >=45) |
                      (as.numeric(format(round3_ref$timestamp, "%H")) == 1 &
                         as.numeric(format(round3_ref$timestamp, "%M")) <=5)), ]

#now let's interpolate
temp_raw <- data.frame()

for (name in names(round3_raw)) {
  if (name != 'timestamp') {
    if (nrow(temp_raw) == 0) {
      temp_raw = interpolate(round3_raw, round3_ref, name)
    } else {
      t = interpolate(round3_raw, round3_ref, name)
      temp_raw[[name]] = t[[name]]
    }
  }
}
round3_raw<- temp_raw

rm(t, temp_raw, name)

#30 minutes averages:
round3_raw_ss <- subsample(round3_raw, '30 mins')
round3_raw_ss$timestamp <- as.POSIXct(round3_raw_ss$timestamp)
round3_ref_ss <- subsample(round3_ref, '30 mins')
round3_ref_ss$timestamp <- as.POSIXct(round3_ref_ss$timestamp)

# put everything together in one data frame
round3_ss <- round3_raw_ss
round3_ss$refNO2 = round3_ref_ss$NO2

#this adds some NaN where the holes are, let's remove them:
round3_ss = round3_ss[which(!is.nan(round3_ss$millis)), ]


#let's add the squared of each input
round3_ss$temperature_sq = round3_ss$temperature ^ 2
round3_ss$humidity_sq = round3_ss$humidity ^ 2
round3_ss$custom_MICS_sq = round3_ss$custom_MICS ^ 2
round3_ss$pressure_sq = round3_ss$pressure ^ 2
round3_ss$alphadiff_sq = round3_ss$alphadiff ^ 2
round3_ss$cjmcu_red_sq = round3_ss$cjmcu_red ^ 2
round3_ss$cjmcu_ox_sq = round3_ss$cjmcu_ox ^ 2

# we can delete the other data
rm(round3_raw_ss, round3_ref_ss)
```


What happens if we use the model from round 1?

```{r}
errs_r1_m_thm_r3 <- data.frame(timestamp = round3_ss$timestamp, reference = round3_ss$refNO2, fitted = predict(round1_model_thm, round3_ss))

# remove absurd spikes:
errs_r1_m_thm_r3 <- errs_r1_m_thm_r3[which(abs(errs_r1_m_thm_r3$fitted) < 100), ]

print(paste('mean error', mean(errs_r1_m_thm_r3$reference - errs_r1_m_thm_r3$fitted), 'ppb'))
print(paste('mean absolute error', mean(abs(errs_r1_m_thm_r3$reference - errs_r1_m_thm_r3$fitted)), 'ppb'))

xrange <- range(errs_r1_m_thm_r3$timestamp)

plot(errs_r1_m_thm_r3$timestamp, errs_r1_m_thm_r3$reference, type='l', xlab='time', ylab='ppb', col = 'red')
axis.POSIXct(1, at=seq(xrange[1], xrange[2], by="day"), format="%b %d")
lines(errs_r1_m_thm_r3$timestamp, errs_r1_m_thm_r3$fitted, type='l', lty = 2, col = 'blue')
legend("topright", legend = c("reference", "fitted_r1"),
       text.width = strwidth("reference"),
       col=c('red', 'blue'),
       lty = 1:2, xjust = 1, yjust = 1)

rm(xrange)

```

surprisingly, it doesn't look too bad !

Let's see if use the first model of round 2:

```{r}
errs_r2_m_thm_r3 <- data.frame(timestamp = round3_ss$timestamp, reference = round3_ss$refNO2, fitted = predict(round2_model_thm, round3_ss))

errs_r2_m_thm_r3 <- errs_r2_m_thm_r3[which(abs(errs_r2_m_thm_r3$fitted) < 100), ]

print(paste('mean error', mean(errs_r2_m_thm_r3$reference - errs_r2_m_thm_r3$fitted), 'ppb'))
print(paste('mean absolute error', mean(abs(errs_r2_m_thm_r3$reference - errs_r2_m_thm_r3$fitted)), 'ppb'))

xrange <- range(errs_r2_m_thm_r3$timestamp)

plot(errs_r2_m_thm_r3$timestamp, errs_r2_m_thm_r3$reference, type='l', xlab='time', ylab='ppb', col = 'red')
axis.POSIXct(1, at=seq(xrange[1], xrange[2], by="day"), format="%b %d")
lines(errs_r2_m_thm_r3$timestamp, errs_r2_m_thm_r3$fitted, type='l', lty = 2, col = 'blue')
legend("topright", legend = c("reference", "fitted_r1"),
       text.width = strwidth("reference"),
       col=c('red', 'blue'),
       lty = 1:2, xjust = 1, yjust = 1)

rm(xrange)
```

Looks quite similar to the one from round 1, although actually performs worse.

Now with the second and more precise model:

```{r}
errs_r2_m_thmpa_r3 <- data.frame(timestamp = round3_ss$timestamp, reference = round3_ss$refNO2, fitted = predict(round2_model_thmpa, round3_ss))

print(paste('mean error', mean(errs_r2_m_thmpa_r3$reference - errs_r2_m_thmpa_r3$fitted), 'ppb'))
print(paste('mean absolute error', mean(abs(errs_r2_m_thmpa_r3$reference - errs_r2_m_thmpa_r3$fitted)), 'ppb'))

```

This is completely out of range.
Why is that? Maybe the way some of these variable were measured have changed?

If we remove the pressure?

```{r}
errs_r2_m_thma_r3 <- data.frame(timestamp = round3_ss$timestamp, reference = round3_ss$refNO2, fitted = predict(round2_model_thma, round3_ss))

print(paste('mean error', mean(errs_r2_m_thma_r3$reference - errs_r2_m_thma_r3$fitted), 'ppb'))
print(paste('mean absolute error', mean(abs(errs_r2_m_thma_r3$reference - errs_r2_m_thma_r3$fitted)), 'ppb'))
```
OK, that's not gonna work.


Let's build the same models using round 3 data, but only using the first week of data:

```{r}
round3_ss_week1 <- round3_ss[which( difftime(round3_ss$timestamp, round3_ss[1, 'timestamp'], units=c('days')) <7 ), ]
# this actually less than a week!

round3_model_thm <- lm(refNO2 ~
                          custom_MICS + custom_MICS_sq +
                          temperature_sq + humidity_sq +
                          custom_MICS * temperature +
                          custom_MICS * humidity
                        , data=round3_ss_week1)
summary(round3_model_thm)

round3_model_thma <- lm(refNO2 ~
                            temperature_sq + humidity_sq +
                            
                            custom_MICS + custom_MICS_sq +
                            custom_MICS * temperature +
                            custom_MICS * humidity +

                            alphadiff + alphadiff_sq +
                            alphadiff * temperature +
                            alphadiff * humidity
                          , data=round3_ss_week1)
summary(round3_model_thma)

round3_model_thmpa <- lm(refNO2 ~
                            temperature_sq + humidity_sq + pressure_sq +
                            
                            custom_MICS + custom_MICS_sq +
                            custom_MICS * temperature +
                            custom_MICS * humidity +
                            custom_MICS * pressure +
                            
                            alphadiff + alphadiff_sq +
                            alphadiff * temperature +
                            alphadiff * humidity +
                            alphadiff * pressure
                          , data=round3_ss_week1)
summary(round3_model_thmpa)

errs_r3_m_thm_r3 <- data.frame(timestamp = round3_ss$timestamp, reference = round3_ss$refNO2, fitted = predict(round3_model_thm, round3_ss))
errs_r3_m_thm_r3 <- errs_r3_m_thm_r3[which(abs(errs_r3_m_thm_r3$fitted) < 100), ]

print(paste('THM mean absolute error', mean(abs(errs_r3_m_thm_r3$reference - errs_r3_m_thm_r3$fitted)), 'ppb'))

errs_r3_m_thma_r3 <- data.frame(timestamp = round3_ss$timestamp, reference = round3_ss$refNO2, fitted = predict(round3_model_thma, round3_ss))
errs_r3_m_thma_r3 <- errs_r3_m_thma_r3[which(abs(errs_r3_m_thma_r3$fitted) < 100), ]

print(paste('THMA mean absolute error', mean(abs(errs_r3_m_thma_r3$reference - errs_r3_m_thma_r3$fitted)), 'ppb'))

errs_r3_m_thmpa_r3 <- data.frame(timestamp = round3_ss$timestamp, reference = round3_ss$refNO2, fitted = predict(round3_model_thmpa, round3_ss))
errs_r3_m_thmpa_r3 <- errs_r3_m_thmpa_r3[which(abs(errs_r3_m_thmpa_r3$fitted) < 100), ]

print(paste('THMPA mean absolute error', mean(abs(errs_r3_m_thmpa_r3$reference - errs_r3_m_thmpa_r3$fitted)), 'ppb'))

xrange <- range(errs_r3_m_thm_r3$timestamp)

plot(errs_r3_m_thm_r3$timestamp, errs_r3_m_thm_r3$reference, type='l', xlab='time', ylab='ppb', col = 'red')
axis.POSIXct(1, at=seq(xrange[1], xrange[2], by="day"), format="%b %d")
lines(errs_r3_m_thm_r3$timestamp, errs_r3_m_thm_r3$fitted, type='l', lty = 2, col = 'blue')
legend("topright", legend = c("reference", "THM"),
       text.width = strwidth("reference"),
       col=c('red', 'blue'),
       lty = 1:2, xjust = 1, yjust = 1)

xrange <- range(errs_r3_m_thma_r3$timestamp)

plot(errs_r3_m_thma_r3$timestamp, errs_r3_m_thma_r3$reference, type='l', xlab='time', ylab='ppb', col = 'red')
axis.POSIXct(1, at=seq(xrange[1], xrange[2], by="day"), format="%b %d")
lines(errs_r3_m_thma_r3$timestamp, errs_r3_m_thma_r3$fitted, type='l', lty = 2, col = 'blue')
legend("topright", legend = c("reference", "THMA"),
       text.width = strwidth("reference"),
       col=c('red', 'blue'),
       lty = 1:2, xjust = 1, yjust = 1)

xrange <- range(errs_r3_m_thmpa_r3$timestamp)

plot(errs_r3_m_thmpa_r3$timestamp, errs_r3_m_thmpa_r3$reference, type='l', xlab='time', ylab='ppb', col = 'red')
axis.POSIXct(1, at=seq(xrange[1], xrange[2], by="day"), format="%b %d")
lines(errs_r3_m_thmpa_r3$timestamp, errs_r3_m_thmpa_r3$fitted, type='l', lty = 2, col = 'blue')
legend("topright", legend = c("reference", "THMPA"),
       text.width = strwidth("reference"),
       col=c('red', 'blue'),
       lty = 1:2, xjust = 1, yjust = 1)

rm(xrange)
```

What's interesting in these charts is that it clearly shows the overfitting in the first week.
The THM does quite OK, but the overall accuracy is not great, the THMA seems better at picking spikes and doesn't degrade too much over time, but has lower overall accuracy than THM alone, the THMPA does very well in the first week, but then it looses accuracy.



Let's add also the new sensor, the CJMCU 4541.
First of all, are the MICS and the CJMCU different? Let's find it out:

```{r}
xrange <- range(round3_raw$timestamp)

plot(round3_raw$timestamp, round3_raw$custom_MICS, type='l', xlab='time', col = 'red')
axis.POSIXct(1, at=seq(xrange[1], xrange[2], by="day"), format="%b %d")
lines(round3_raw$timestamp, round3_raw$cjmcu_ox, type='l', lty = 2, col = 'blue')
legend("topright", legend = c("MICS", "CJMCU"),
       text.width = strwidth("CJMCU"),
       col=c('red', 'blue'),
       lty = 1:2, xjust = 1, yjust = 1)
```
They look almost identical except from a scaling factor. So we should expect almost identical results if we use the MICS or the CJMCU.

We train the model on the first week of the dataset only as before. We treat the cjmcu variables as the custom_MICS, this will generate many more variables!

```{r}
round3_ss$cjmcu_red_sq = round3_ss$cjmcu_red ^ 2
round3_ss$cjmcu_ox_sq = round3_ss$cjmcu_ox ^ 2

round3_model3_thmac <- lm(refNO2 ~
                             temperature_sq + humidity_sq +
                             
                             custom_MICS + custom_MICS_sq +
                             custom_MICS * temperature +
                             custom_MICS * humidity +

                             alphadiff + alphadiff_sq +
                             alphadiff * temperature +
                             alphadiff * humidity +

                             cjmcu_red + cjmcu_red_sq +
                             cjmcu_red * temperature +
                             cjmcu_red * humidity +

                             cjmcu_ox + cjmcu_ox_sq +
                             cjmcu_ox * temperature +
                             cjmcu_ox * humidity
                           , data=round3_ss_week1)
summary(round3_model3_thmac)

errs_r3_m_thmac_r3 <- data.frame(timestamp = round3_ss$timestamp, reference = round3_ss$refNO2, fitted = predict(round3_model3_thmac, round3_ss))
errs_r3_m_thmac_r3 <- errs_r3_m_thmac_r3[which(abs(errs_r3_m_thmac_r3$fitted) < 100), ]

print(paste('THMAC mean absolute error', mean(abs(errs_r3_m_thmpa_r3$reference - errs_r3_m_thmpa_r3$fitted)), 'ppb'))

xrange <- range(errs_r3_m_thmac_r3$timestamp)

plot(errs_r3_m_thmac_r3$timestamp, errs_r3_m_thmac_r3$reference, type='l', xlab='time', ylab='ppb', col = 'red')
axis.POSIXct(1, at=seq(xrange[1], xrange[2], by="day"), format="%b %d")
lines(errs_r3_m_thmac_r3$timestamp, errs_r3_m_thmac_r3$fitted, type='l', lty = 2, col = 'blue')
legend("topright", legend = c("reference", "THMAC"),
       text.width = strwidth("reference"),
       col=c('red', 'blue'),
       lty = 1:2, xjust = 1, yjust = 1)

rm(xrange)
```

Again, even more overfitted.

OK, let's focus on alphasense only, is that the messes it up?

```{r}
round3_model_tha <- lm(refNO2 ~
                          temperature + humidity +
                          temperature_sq + humidity_sq +
                          alphadiff + alphadiff_sq +
                          alphadiff * temperature +
                          alphadiff * humidity
                        , data=round3_ss_week1)
summary(round3_model_tha)

errs_r3_m_tha_r3 <- data.frame(timestamp = round3_ss$timestamp, reference = round3_ss$refNO2, fitted = predict(round3_model_tha, round3_ss))
errs_r3_m_tha_r3 <- errs_r3_m_tha_r3[which(abs(errs_r3_m_tha_r3$fitted) < 100), ]

print(paste('THA mean absolute error', mean(abs(errs_r3_m_tha_r3$reference - errs_r3_m_tha_r3$fitted)), 'ppb'))

xrange <- range(errs_r3_m_tha_r3$timestamp)

plot(errs_r3_m_tha_r3$timestamp, errs_r3_m_tha_r3$reference, type='l', xlab='time', ylab='ppb', col = 'red')
axis.POSIXct(1, at=seq(xrange[1], xrange[2], by="day"), format="%b %d")
lines(errs_r3_m_tha_r3$timestamp, errs_r3_m_tha_r3$fitted, type='l', lty = 2, col = 'blue')
legend("topright", legend = c("reference", "fitted"),
       text.width = strwidth("reference"),
       col=c('red', 'blue'),
       lty = 1:2, xjust = 1, yjust = 1)

rm(xrange)
```

Looks like the overall performances are worse than just the MICS and the drift is actually high.

What if we remove alphasense then? Can we trust only the CJMCU 4541 ? In principle the MICS should be redundant!
We can also try with only the NOX channel!

```{r}
round3_model_thc <- lm(refNO2 ~
                             temperature_sq + humidity_sq +
                             
                             cjmcu_red + cjmcu_red_sq +
                             cjmcu_red * temperature +
                             cjmcu_red * humidity +

                             cjmcu_ox + cjmcu_ox_sq +
                             cjmcu_ox * temperature +
                             cjmcu_ox * humidity +

                             cjmcu_red * cjmcu_ox
                           , data=round3_ss_week1)
summary(round3_model_thc)

errs_r3_m_thc_r3 <- data.frame(timestamp = round3_ss$timestamp, reference = round3_ss$refNO2, fitted = predict(round3_model_thc, round3_ss))
errs_r3_m_thc_r3 <- errs_r3_m_thc_r3[which(abs(errs_r3_m_thc_r3$fitted) < 100), ]

print(paste('TCH with RED mean absolute error', mean(abs(errs_r3_m_thc_r3$reference - errs_r3_m_thc_r3$fitted)), 'ppb'))


round3_model_thc2 <- lm(refNO2 ~
                             temperature_sq + humidity_sq +
                             
                             cjmcu_ox + cjmcu_ox_sq +
                             cjmcu_ox * temperature +
                             cjmcu_ox * humidity
                           , data=round3_ss_week1)
summary(round3_model_thc2)
errs_r3_m_thc2_r3 <- data.frame(timestamp = round3_ss$timestamp, reference = round3_ss$refNO2, fitted = predict(round3_model_thc2, round3_ss))
errs_r3_m_thc2_r3 <- errs_r3_m_thc2_r3[which(abs(errs_r3_m_thc2_r3$fitted) < 100), ]

print(paste('THC NO RED mean absolute error', mean(abs(errs_r3_m_thc2_r3$reference - errs_r3_m_thc2_r3$fitted)), 'ppb'))

xrange <- range(errs_r3_m_thc_r3$timestamp)

plot(errs_r3_m_thc_r3$timestamp, errs_r3_m_thc_r3$reference, type='l', xlab='time', ylab='ppb', col = 'red')
axis.POSIXct(1, at=seq(xrange[1], xrange[2], by="day"), format="%b %d")
lines(errs_r3_m_thc_r3$timestamp, errs_r3_m_thc_r3$fitted, type='l', lty = 2, col = 'blue')
legend("topright", legend = c("reference", "THC"),
       text.width = strwidth("reference"),
       col=c('red', 'blue'),
       lty = 1:2, xjust = 1, yjust = 1)

xrange <- range(errs_r3_m_thc2_r3$timestamp)

plot(errs_r3_m_thc2_r3$timestamp, errs_r3_m_thc2_r3$reference, type='l', xlab='time', ylab='ppb', col = 'red')
axis.POSIXct(1, at=seq(xrange[1], xrange[2], by="day"), format="%b %d")
lines(errs_r3_m_thc2_r3$timestamp, errs_r3_m_thc2_r3$fitted, type='l', lty = 2, col = 'blue')
legend("topright", legend = c("reference", "THC1"),
       text.width = strwidth("reference"),
       col=c('red', 'blue'),
       lty = 1:2, xjust = 1, yjust = 1)
rm(xrange)
```

So the one that includes the RED channel is overfitted, but the one with only the NOX channel does fine, like if we used only the custom_MICS.

So if we add also the Alphasense?

```{r}
round3_model_thac2 <- lm(refNO2 ~
                          temperature_sq + humidity_sq +
                          
                          alphadiff + alphadiff_sq +
                          alphadiff * temperature +
                          alphadiff * humidity +
                          
                          cjmcu_ox + cjmcu_ox_sq +
                          cjmcu_ox * temperature +
                          cjmcu_ox * humidity
                        , data=round3_ss_week1)
summary(round3_model_thac2)
errs_r3_m_thac2_r3 <- data.frame(timestamp = round3_ss$timestamp, reference = round3_ss$refNO2, fitted = predict(round3_model_thac2, round3_ss))
errs_r3_m_thac2_r3 <- errs_r3_m_thac2_r3[which(abs(errs_r3_m_thac2_r3$fitted) < 100), ]

print(paste('THAC NO RED mean absolute error', mean(abs(errs_r3_m_thc_r3$reference - errs_r3_m_thc_r3$fitted)), 'ppb'))

xrange <- range(errs_r3_m_thac2_r3$timestamp)

plot(errs_r3_m_thac2_r3$timestamp, errs_r3_m_thac2_r3$reference, type='l', xlab='time', ylab='ppb', col = 'red')
axis.POSIXct(1, at=seq(xrange[1], xrange[2], by="day"), format="%b %d")
lines(errs_r3_m_thac2_r3$timestamp, errs_r3_m_thac2_r3$fitted, type='l', lty = 2, col = 'blue')
legend("topright", legend = c("reference", "THC"),
       text.width = strwidth("reference"),
       col=c('red', 'blue'),
       lty = 1:2, xjust = 1, yjust = 1)
```


The results are worse than with the CJMCU alone.

## Conclusions

If we include all sorts of sensors the fitting with the data can increase substantially, but it will be overfitted.
The good old MICS 2714 seems to be working consistently well or bad depending on hwo you see it.

If we plot the error over time, to understand drift, using the model from the first round:

```{r}
errs_r1_thm_all <- errs_r1_m_thm_r1
errs_r1_thm_all <- rbind(errs_r1_thm_all, errs_r1_m_thm_r2)
errs_r1_thm_all <- rbind(errs_r1_thm_all, errs_r1_m_thm_r3)

errs_r1_thm_all$abserror <- abs(errs_r1_thm_all$reference - errs_r1_thm_all$fitted)

errs_r1_thm_all$weeks <- floor(difftime(errs_r1_thm_all$timestamp, errs_r1_thm_all[1, 'timestamp'], units=c('week')))

boxplot(abserror~weeks, data=errs_r1_thm_all, main="Drift of Mics 2714 + temp + hum", 
   xlab="Weeks from calibration", ylab="Error (ppb)")
```

There seems to be some sort of drift, because the error seems to become more spread in the weeks 85 to 92 compared to week 34, but, because there are no other weeks to check in between, it's hard to say.

Let's compare the solution with Mics and Alphasense:

```{r}
errs_r3_m_thma_r3$abserror <- abs(errs_r3_m_thma_r3$reference - errs_r3_m_thma_r3$fitted)

errs_r3_m_thma_r3$weeks <- floor(difftime(errs_r3_m_thma_r3$timestamp, errs_r3_m_thma_r3[1, 'timestamp'], units=c('week')))

boxplot(abserror~weeks, data=errs_r3_m_thma_r3, main="Drift of Mics 2714 + temp + hum + Alphasense", 
   xlab="Weeks from calibration", ylab="Error (ppb)")
```

The situation is similar, with overall higher errors though especially considering that the model is much more close in time than the one shown above.


Other conclusions we can derive are:

- pressure doesn't add anything useful and should probably be excluded
- the RED channel of the CJMCU should be ignored
- the Alphasense sensor can lead to excellent results when overfitting, but otherwise doesn't seem to add any useful information


